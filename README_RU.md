( Это документ README для основного репозитария  [https://github.com/heroqu/react-i18n-site](https://github.com/heroqu/react-i18n-site).
The English version is [here](./README.md) )

# Проект React Сайт с i18n

Этот проект я разработал для моего сайта под портфолио проектов.

Вкратце это сайт на React в котором есть:

- SPA
- i18n
- Docker микросервисы на бэкенде
- отдельные подпроекты для контент менеджмента и переводов
- и другое...

Ниже приводим подробное описание его архитектуры и строительных блоков.

## Оглавление

<!-- toc -->

  * [Цели и приоритеты](#Цели-и-приоритеты)
* [Подпроекты](#Подпроекты)
* [Функциональные аспекты](#Функциональные-аспекты)
  * [Интернационализация и контент менеджмент](#Интернационализация-и-контент-менеджмент)
  * [Маршрутизация в приложении](#Маршрутизация-в-приложении)
    * [Режим Одностраничного Приложения (SPA)](#Режим-Одностраничного-Приложения-spa)
    * [Маршруты, Перенаправление и i18n](#Маршруты-Перенаправление-и-i18n)
  * [Соглашение по наименованию страниц](#Соглашение-по-наименованию-страниц)
  * [Внешний вид](#Внешний-вид)
    * [Oбщая компоновка страницы](#oбщая-компоновка-страницы)
    * [Стиль и темы](#Стиль-и-темы)
    * [Самостоятельный хостинг шрифтов](#Самостоятельный-хостинг-шрифтов)
  * [Бэкенд](#Бэкенд)
    * [http сервер для сайта](#http-сервер-для-сайта)
    * [Mailer](#mailer)
    * [Контейнеризация и Микросервисы](#Контейнеризация-и-Микросервисы)
* [1. React сайт](#1-react-сайт)
  * [Дерево компонентов](#Дерево-компонентов)
  * [App](#app)
  * [Redux](#redux)
  * [Router](#router)
    * [LocaleRouter](#localerouter)
    * [ScrollToTop](#scrolltotop)
  * [Intl](#intl)
  * [Theme](#theme)
  * [Layout](#layout)
    * [Header](#header)
    * [Footer](#footer)
    * [Content](#content)
  * [Компоненты разного назначения](#Компоненты-разного-назначения)
    * [Meta](#meta)
    * [NotFound](#notfound)
    * [LanguagePanel](#languagepanel)
    * [MenuTop](#menutop)
    * [MenuLeft](#menuleft)
    * [LastBuilt](#lastbuilt)
  * [React компоненты, встраиваемые в страницы](#react-компоненты-встраиваемые-в-страницы)
    * [Идея](#Идея)
    * [Список используемых в настоящее время](#Список-используемых-в-настоящее-время)
    * [Загрузка данных и кэширование](#Загрузка-данных-и-кэширование)
    * [Projects](#projects)
    * [ProjectFilter](#projectfilter)
    * [ProjectList](#projectlist)
    * [Accordion & AccordionSection](#accordion-accordionsection)
    * [ProjectTitle](#projecttitle)
    * [ProjectCard](#projectcard)
    * [MarkDown](#markdown)
    * [Gallery](#gallery)
    * [ResumeDownload](#resumedownload)
    * [AppLink](#applink)
    * [Link](#link)
    * [A](#a)
    * [ALink](#alink)
    * [MailForm](#mailform)
* [2. Authoring](#2-authoring)
* [3. Translating](#3-translating)
* [4. Mailer](#4-mailer)
* [5. Deploy](#5-deploy)
  * [Some specificities in Dockerfiles](#some-specificities-in-dockerfiles)
  * [docker-compose.yml](#docker-composeyml)

<!-- tocstop -->

## Цели и приоритеты

С самого начала разработки я поставил перед собой ряд целей и приоритетов. И вот то, что было реально достигнуто:

- Воздержаться от громоздких готовых решений типа все-в-одном (CMS, генераторов статических сайтов и т.п.), сохраняя максимальный контроль над кодом и избегая ловушек vendor locking.
- Построить сайт как одностраничное приложение (SPA).
- Постараться удержаться в пределах стандартной системы сборки от create-react-app.
- Предусмотреть полную интернационализацию (i18n), с простым добавлением новых языков на уровне конфигурационных файлов.
- Выделить подготовку переводов для i18n в отдельный подпроект и автоматизировать его рутинные операции.
- Использовать компонентный стиль разработки, максимального разграничивая роли отдельных компонентов и подсистем.
- Выделить задачу контент менеджмента в отдельный подпроект и максимально освободить ее от вопросов программирования.
- Использовать при написании контента старый добрый HTML, добавив к простоте и универсальности этого языка возможность вставлять в разметку произвольные React компоненты.
- Встраиваемые React компоненты, которым требуется подгрузка данных, должны осуществлять эту подгрузку в режиме "по-требованию", позволяя основному приложению стартовать быстрее.
- Всякий раз, когда какой-то встроенный React компонент требует для своей работы определенную функцию на бэкенде, не связанную с основным сервером сайта, такая функция должна быть выделена в отдельный сервер (в конечном счете – в микросервис).
- Оформить все серверы сайта как Docker контейнеры.
- Организовать запуск всего сайта как связку Docker-микросервисов при помощи Docker-compose.
- Найти хостинг провайдер, поддерживающий Docker и максимально простую и неспецифичную процедуру выкладки в продакшн, в идеале командой docker-compose, чтобы в случае необходимости можно было бы без труда перейти к другому провайдеру.

# Подпроекты

К настоящему моменту весь проект вырос в пять следующих подпроектов, каждый с своей собственной под-директории и со своим собственным репозитарием git:

```
root
  ├─ site
  ├─ authoring
  ├─ translating
  ├─ mailer
  └─ deploy
```

Где:

1.  [Site](#1-site-the-react-application) – основной подпроект. Собственно React приложение + http сервер для статического контента
2.  [Authoring](#2-authoring) – рабочее место контент-менеджера. Здесь можно готовить тексты основных страниц.
3.  [Translating](#3-translating) – подпроект, помогающий подготовить переводы ключевых фраз для системы i18n
4.  [Mailer](#4-mailer) – бэкенд, обслуживающий форму обратной связи (компонент MailForm, размещенный на странице Контакты)
5.  [Deploy](#5-deploy) – подпроект с конфигурацией Docker-compose для запуска всего сайта в виде связки микросервисов и для размещения на хостинг провайдере с поддрержкой Docker.

Расположение подпроектов в соседних папках не обязательно, но удобно, так как упрощает взаимодействие, как, например:

- извлечение ключей перевода из __site__ в __translating__
- экспорт результатов из __authoring__ и __translating__ в __site__
- запуск микросервисов в __deploy__, с обращением к директориям __site__ и __mailer__

Подробнее о каждом из подпроектов см. соответствующих подразделах этого документа. Но сначала рассмотрим сайт в функциональном разрезе:

# Функциональные аспекты

## Интернационализация и контент менеджмент

Сайт полностью интернационализирован (на данный момент задействованы два языка, английский и русский, другие языки могут быть добавлены на уровне конфигурационных файлов), и контент менеджмент пересекается с этой интернационализацией напрямую.

Есть три типа источников, откуда контент может поступать на экраны сайта:

1.  __Небольшие куски текстов__ в пунктах меню, надписях на кнопках, в тексте подвала и т.п.).

Все такие тексты обслуживаются пакетом интернационализации [React-intl](https://www.npmjs.com/package/react-intl), и есть отдельный подпроект [Translating](#3-translating) по управлению переводами ключевых фраз для этого пакета.

2.  __Тексты основных страниц__ на сайте (такие как _Введение_, _Опыт_, _Контакты_ и т.д.).

Подразумевается что это самая значительная доля всего контента сайта и есть отдельный подпроект [Authoring](#2-authoring), в рамках которого контент менеджер может заниматься подготовкой таких страниц, готовя по одной странице каждого типа для каждого из языков сайта.

3.  __Контент внутри встраиваемых компонентов__ (подробнее про них см. в разделе [встраиваемые компоненты](#react-components-embedded-in-content-pages) ниже).

Применяемая здесь стратегия должна определяться индивидуально для каждого такого компонента.

В целом ясно одно: если компонент имеет какие-то элементы UI с текстами – такие тексты прямые кандидаты для использования функционала [React-intl](https://www.npmjs.com/package/react-intl).

Некоторые встраиваемые компоненты могут подгружать свои данные из внешних источников уже после монтрирования на страницу. В таких случаях следует решить, какой из подходов более уместен: использовать ли [React-intl](https://www.npmjs.com/package/react-intl) для автоматического перевода (а также форматирования и функций множественно числа), или же получать все тексты из источника данных уже в готовом виде на всех языках.

В настоящий момент на своем сайте я использую два компонента с загрузкой данных: [Projects](#projects) и [Gallery](#gallery). Для каждого из них все переводы текстов сделаны заранее и находятся в файлах данных  – `projects.json` и `gallery.json` соответственно.

Внутри компонента `Projects` есть текстовые елементы UI – вот для них я задействую функции перевода из [React-intl](https://www.npmjs.com/package/react-intl). Но все главные тексты – в основном это описания каждого из проектов – все это переведено вручную и хранится файле источнике целиком и в готовом виде.

## Маршрутизация в приложении

### Режим Одностраничного Приложения (SPA)

Сайт работает в режиме Одностраничного Приложения (Single Page Application, SPA), что достигается за счет использования пакета [React-router](https://www.npmjs.com/package/react-router), который берет под свой контроль объекты браузера __history__ и __location__. Все внутренние ссылки реализуются через использование компонента `Link` из этого пакета, и это дает навигацию внутри сайта без перезагрузки приложения со стороны браузера.

### Маршруты, Перенаправление и i18n

Я установил для приложения два правила (можно считать их бизнес требованиями):

1.  __Корневой URL должен быть перенаправлен на домашнюю страницу__

    На данный момент я использую перенаправление `/ -> /intro`, со стартовой страницей   _Intro_ / _Введение_.

2.  __Страницы сайта на всех языках кроме основного должны в адресе URL иметь префикс языка__

    Так, например, если основной язык английский, а два другие русский и немецкий, то адреса страницы _About_ на этих языках будут выглядеть так:

    ```
    English:    /about
    Russian:    /ru/about
    German:     /de/about
    ```

Оба эти правила реализованы в компоненте [Router](#router), который инкапсулирует в себе всю логику маршрутизации внутри приложения.

## Соглашение по наименованию страниц

Страницы, изначально создаваемые в подпроекте Authoring, должны придерживаться следующего стиля именования:

```
.../pages/en/you-dont-know.pug
```

далее, после автоматической конвертации в React JSX это уже:

```
.../pages/en/you-dont-know.js
```

При этом сами компоненты (тоже автоматически) приобретают имена вида:

``` JavaScript
class Page__you_dont_know extends Component {...}
```

Далее для правильной работы основной навигации мы должны в файле переводов React-Intl иметь ключи основных страниц в таком виде:

``` JSON
{
  "en": {
    "nav.you-dont-know": "You don't know..."

  },
  "ru": {
    "nav.you-dont-know": "Вы не знаете..."
  }
}
```

Это в свою очередь дает на выходе URL адреса вида:

```
http://some.domain/you-dont-know
```

Подводя итог, мы должны проследить за правильным именованием исходных файлов PUG и за наличием правильных ключей к этим страницам в файле переводов `messages.json`. Это даст совпадение ссылок меню навигации с ключами реально существующих страниц.

## Внешний вид

### Oбщая компоновка страницы

Общую компоновку станицы задает компонент [Layout](#layout), который выводит на экран компоненты [Header](#header), [Content](#content) и [Footer](#footer), причем обеспечивает прилипание Footer-а к нижней границе страницы ([средствами CSS](https://github.com/heroqu/react-i18n-site/blob/master/src/Layout/Layout.css)).

### Стиль и темы

Часть стилей CSS задействуется посредством CSS модулей, которые подгружаются в нескольких ключевых точках на иерархии React компонентов:

- [Theme](#theme) (модуль, подключающий базовый CSS и задающий тему для Material-UI)
- [Layout](#layout)
- [Content](#content) (выводит главные страницы сайта)
- [Footer](#footer)
- [Projects](#projects) (компонент, внедренный в одну из страниц)

Некоторые части сайта (например, [боковое меню](#menuleft), [верхнее меню](#menutop), [почтовая форма](#mailform), [панель выбора языка](#languagepanel)) используют компоненты из пакета [Material-UI](https://www.npmjs.com/package/@material-ui/core), которые в свою очередь задействуют технологию CSS-in-JS, и их стили настраиваются из разных мест: частично непосредственно в модулях где они используются, частично под влиянием компонента [Theme](#theme) – провайдера тем для Material-UI, расположенного ближе к вершине иерархии компонентов.

### Самостоятельный хостинг шрифтов

Я использую локальное размещение используемых на сайте шрифтов  ([Arsenal](https://fonts.google.com/specimen/Arsenal) для всех текстов, [Roboto](https://fonts.google.com/specimen/Roboto) для элементов Material-UI), то есть webpack включает их непосредственно в сборку приложения.

[По оценкам](https://www.bricolage.io/typefaces-easiest-way-to-self-host-fonts/), это может экономить от 300 до 1000 миллисекунд во время первого старта приложения.

Директория `fonts` выглядит так:

```
fonts
├── index.js
├── arsenal-cyrillic
│   ├── index.js
│   └── 400
│       ├── arsenal-regular-cyrillic.woff
│       ├── arsenal-regular-cyrillic.woff2
│       ├── index.css
│       └── index.js
└── roboto-cyrillic
    ├── index.js
    ├── 300
    │   ├── index.css
    │   ├── index.js
    │   ├── roboto-light-cyrillic.woff
    │   └── roboto-light-cyrillic.woff2
    ├── 400
    │   ├── index.css
    │   ├── index.js
    │   ├── roboto-regular-cyrillic.woff
    │   └── roboto-regular-cyrillic.woff2
    └── 500
        ├── index.css
        ├── index.js
        ├── roboto-medium-cyrillic.woff
        └── roboto-medium-cyrillic.woff2
```

Мы видим, что на каждом уровне расположены файлы __index.js__, и именно это позволяет загрузить все необходимые шрифты в приложение одной единственной неспецифичной командой import:

```JavaScript
import './fonts'
```

Проследим нить загрузки от начала до конца:

Сначала мы достигаем файла `fonts/index.js`, который устроен так:

```JavaScript
// fonts/index.js
import './roboto-cyrillic'
import './arsenal-cyrillic'
```

Затем мы попадаем в файлы `fonts/roboto-cyrillic/index.js` и `fonts/arsenal-cyrillic/index.js`, первый из которых выглядит так:

```JavaScript
// fonts/roboto-cyrillic/index.js
import './300'
import './400'
import './500'
```

Далее видим три файла, посмотрим на первый:

```JavaScript
// fonts/roboto-cyrillic/300/index.js
import './index.css'
```

Здесь, наконец, мы получаем файл CSS:

```css
/* fonts/roboto-cyrillic/300/index.css  */
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-display: swap;
  font-weight: 300;
  src: local('Roboto Light '), local('Roboto-Light'),
    url('roboto-light-cyrillic.woff2') format('woff2'), /* Super Modern Browsers */
    url('roboto-light-cyrillic.woff') format('woff'); /* Modern Browsers */
}
```

В итоге мы получаем конечные файлы с шрифтами – нашу полезную нагрузку.

__Почему не использовать готовые npm `typeface-<имя шрифта>`?__

Изначально я рассматривал имено этот способ. Действительно, есть два отличных npm пакета – [typeface-roboto](https://www.npmjs.com/package/typeface-roboto) and [typeface-arsenal](https://www.npmjs.com/package/typeface-arsenal) – но, как быстро выяснилось, они не годятся для нашего приложения по двум причинам:

1.  Эти пакеты загружают шрифты целиком, включая все их варианты.

    На этом сайте я использую только некоторые из вариантов – вес 300, 400 и 500 для Roboto, вес 300 для Arsenal – и я совсем не использую наклонные шрифты. Поэтому, в моем решении я разрезал CSS файл каждого шрифта на более мелкие файлы – по одному на каждый вариант и каждый в своей под-директории. Далее, я импортирую только те варианты, которые нужны. Все это вместе дало снижение размера загрузки примерно раза в четыре, а это много.

2.  Шрифты, входящие в эти npm пакеты содержат только латинское подмноженство символов, что было бы неплохо для чисто англоязычного сайта, но мы здесь идем по пути i18n.

    Поэтому я скачал и использую файлы __`.woff`__ и __`.woff2`__ обоих шрифтов с наборами символов __latin + cyrillic__.

Тем не менее, заслуга за изначальную идею и ее реализацию принадлежит Kyle Mathews, автору указанных npm (см. подоробнее его статью [Typefaces: The easiest way to self-host open-source fonts](https://www.bricolage.io/typefaces-easiest-way-to-self-host-fonts/)), я всего лишь внес здесь небольшие доработки.

## Бэкенд

### http сервер для сайта

Боевая сборка сайта (production build) это просто несколько файлов (index.html, один JavaScript файл, один CCS файл и несколько файлов с картинками, svg, иконками и шрифтами), и, значит, у нас есть выбор из многих http серверов, способных обслуживать статические сайты: Apache, Nginx, Express или даже просто http.Server из ядра Node.

На данный момент я использую http сервер из пакета [serve](https://www.npmjs.com/package/serve).

### Mailer

Компонент [MailForm](#mailform), размещенный на странице Контакты, также нуждается в поддержке со стороны бэкенда, задачей которого была бы доставка почтового сообщения от посетителя.

И всё же, MailForm нельзя назвать неотъемлемой частью сайта как такового, скорее это произвольный компонент, случайно размещенный на одной из страниц сайта по прихоти контент менеджера, поэтому я создал для его обслуживания отдельный *Mailer* сервер (подробнее см. в описании подпроекта [Mailer](#4-mailer)).

### Контейнеризация и Микросервисы

На данный момент бэкенд сайта состоит из двух независимых серверов:

- Site (node + [serve](https://www.npmjs.com/package/serve) static http server)
- Mailer (node + [Express](http://expressjs.com/) http server)

Оба эти сервера могут быть помещены в Docker контейнеры и затем запускаться вместе как два связанных микросервиса (при помощи инструментария [Docker-compose](https://docs.docker.com/compose/)).

Подробнее о том, как именно все это работает см. описание подпроекта [Deploy](#5-deploy).

# 1. React сайт

Основной подпроект, собственно React приложение.

## Дерево компонентов

Вот как выглядит иерархия компонентов React от корня до страниц с контентом:

```
App
└─ Redux                 (Redux provider initialized with Redux store)
   └─ Router                (all app routing logic assembled)
      │
   . . . . . . . . inside of Router: . . . . . . . . . . . . . . . . . . .
   .  │
   .  └─ BrowserRouter         (React-router provider, give SPA mode)
   .     └─ Switch
   .        ├─ Redirect          (Root -> Homepage)
   .        └─ Locale Router     (apply custom i18n URL structure)
   .           ├─ ScrollToTop      (reset position after page switching)
   .           │
   . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
               │
               └─ Intl             (React-intl Provider, initialized with locale data)
                  └─ Theme           (Material-UI theme provider, override base theme)
                     └─ Layout             (make `Sticky Footer` layout)
                        ├─ Header
                        │  ├─ Menu Top           (wide screen)
                        │  ├─ Menu Left          (narrow screen)
                        │  └─ Language Switch    (any screen)
                        ├─ Content               (select which page to mount)
                        │  ├─ Meta               (update HTML document title)  
                        │  ├─ a page      <-- all content pages mount here
                        │  └─ ‘Not Found’ page
                        └─ Footer
                           ├─ ResumeDownload     (take care of what to download)  
                           └─ LastBuilt          (show last build timestamp)
```

Рассмотрим ключевые элементы этой иерархии по порядку.

## App

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/App.js)

Чисто функциональный компонент, который оборачивает основное дерево компонент приложения в несколько слоев контекстных провайдеров, включая маршрутизатор приложения, и, наконец, монтирует [Layout](#layout).

``` JSX
const App = () => (
  <Redux>
    <Router>
      <Intl>
        <Theme>
          <Layout />
        </Theme>
      </Intl>
    </Router>
  </Redux>
)
```

Можно заметить, что все задействованные компоненты не используют `props` в явном виде, что указывает на хороший уровень развязки: каждый компонент действует в значительной степени как черный ящик, в то время как задача `<App>` – расположить их в правильном порядке.

## Redux

Компонент на основе компонента __Provider__ из пакета [React-redux](https://www.npmjs.com/package/react-redux), инициализированного redux store со следующей структурой состояния:

``` JavaScript
{
  locale,
  appUrl
}
```

## Router

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Router/index.js)

Компонент, который скрывает внутри себя всю логику маршрутизации приложения и выглядит так:

```JSX
const Router = ({ children }) => (
  <BrowserRouter>
    <Switch>
      <Redirect exact from="/" to={`/${HOME_PAGE}`} />
      <LocaleRouter>
        <ScrollToTop />
        {children}
      </LocaleRouter>
    </Switch>
  </BrowserRouter>
)
```

Здесь мы видим следующее:

- `<BrowserRouter>` – Контекстный провайдер из пакета  [React-router](https://www.npmjs.com/package/react-router)

- `Switch` (из пакета [React-router](https://www.npmjs.com/package/react-router)) – выводит только самый первый из совпавших маршрутов

- `<Redirect>` (снова из [React-router](https://www.npmjs.com/package/react-router)) – реализует наше _первое бизнес правило_: __“Корневой URL должен быть перенаправлен на домашнюю страницу”__

- `<LocaleRouter>` – компонент, реализующий наше _второе бизнес правило_, и другими словами специальную __языкозависимую структуру URL__. Подробное описание как все это работает см. в следующем разделе [LocaleRouter](#localerouter).

- `<ScrollToTop />` – компонент которой просто перематывает страницу наверх если обнаруживает страница сменилась (подробнее см. в [описании компонента](#scrolltotop)).

- `{children}` – передает эстафету дальше по иерархии приложения.

### LocaleRouter

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Router/LocaleRouter.js)

Отвечает за претворение в жизнь принятой схемы URL:

__“Страницы на всех языках, кроме основного, должны в адресе URL иметь префикс языка.”__.

Вкратце, компонент формирует правильный URL на основании языка полученного из cookie и в случае несовпадения с фактическим URL выполняет перенаправление.

Вот пошаговое описание алгоритма работы этого компонента:

1.  Получить текущее значение locale из cookie
    - для работы с cookie используем пакет [universal-cookie](https://www.npmjs.com/package/universal-cookie)
    - Если cookie пусто, то берем locale основного языка сайта (в нашем случае это __en__)
2.  Извлекаем объект `location` из props (он там есть благодаря функции withRouter, соединяющей компонент с контекстом BrowserRouter из пакета [React-router](https://www.npmjs.com/package/react-router)) и получаем текущее значение URL как `location.pathname`.
3.  Разлагаем полный URL на префикс языка и значимую часть, которую я называю `appUrl`
    - Например, если URL=`/ru/about`, то префикс языка будет `/ru`, а appUrl = `/about`
4.  Если `locale` и/или `appUrl` отличаются от значений в redux store, то запускаем отложенное обновление redux store правильными значениями.
    - Для этого я использую таймер setTimeout(..., 0), который запустит процесс доставки сообщения в redux уже после того, как закончится текущий цикл render
5.  Теперь, когда известны `locale` и `appUrl`, вычисляем правильное значение полного URL.
6.  Сравниваем правильный URL и текущий URL.
7.  Если есть отличия, инициируем перенаправление на исправленный адрес при помощи компоненты `Redirect` из пакета [React-router](https://www.npmjs.com/package/react-router).
    - Есть 2 причины, по которым текущее URL может не совпасть с правильным:
      - неверный текущий префикс языка (`/en/about` вместо правильного `/about`, `/ru/about` вместо `/de/about` и т.д.)
      - присутствие букв в верхнем регистре (`/About` или `/ABOUT` вместо `/about`)
8.  Если отличий нет, то переходим к монтированию дочерних компонентов.

__Примечание #1:__ На этом этапе мы не проверяем реальное существование страницы или ресурса, нас волнует только формат адреса – его соответствие установленным правилам.

__Примечание #2:__ Важно отметить, что именно отложенная отправка `locale` и `appUrl` в redux (упомянутая в пункте 4) в конечном счете приводит к смене текущей страницы, так как компонент [Content](#content) использует `locale` и `appUrl` из props для определения какую из страниц следует вывести на экран. Перенаправление как таковое не является причиной рендеринга или переключения страницы, но оно влияет на объекты `history` и `location` из контекста браузера, синхронизируя их с состоянием приложения (в конце концов как раз в этом суть SPA – поменять местами причину и следствие: всесто `URL -> state` у нас теперь `state -> URL`).

### ScrollToTop

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Router/ScrollToTop.js)

Перематывает страницу наверх, если обнаруживает, что адрес страницы изменился.

Мы вынуждены об этом заботиться, так как в режиме SPA мы фактически отстраняем браузер от обязанностей по перезагрузке страниц. Вот цена узурпации власти.

Взят под копирку из документации к проекту React-router.

## Intl

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Intl/index.js)

Компонент-обертка вокруг компонента IntlProvider из пакета [React-intl](https://www.npmjs.com/package/react-intl), предоставляющего контекстный доступ к своим i18n функциям нижестоящим компонентам иерархии.

Быть оберткой в данном случае означает такие шаги, как загрузка так называемых _данных локализации_ (locale data – форматов и правил множественного числа конкретного языка), а также передачу (через props) текущего значения locale и объекта с переводами ключевых фраз.

Процесс подготовки переводов ключевых фраз подробно описан в разделе [Подпроект Translating](#3-translating).

## Theme

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Theme/index.js)

В этом модуле мы выплняем две задачи:

- активируем основной CSS файл, а именно:
``` JavaScript
import './index.css'
```
- Конструируем компонент `<Theme>`, как обертку вокруг MuiThemeProvider – провайдера тем из пакета [Material-UI](https://www.npmjs.com/package/@material-ui/core) – применяя свой собственный объект тема, переопределяющий некоторые значения по умолчанию для CSS стилей и порогов срабатывания media query.

Сформированная здесь Material-UI тема становится доступной везде ниже по иерархии компонентов.

## Layout

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/Layout/index.js)

Производит основную компоновку страницы, выводя на экран три раздела:

- Header
- Content
- Footer

Применяет приемы CSS для того, чтобы Footer прилипал к нижней границе странице при недостаточной высоте остального контента.

Я выделил этот функционал в отдельную компоненту с одной единственной четкой задачей: компоновка и нечего кроме компоновки.

### Header

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Header/index.js)

Компонент, выводящий на экран три дочерних компонента, [MenuTop](#menutop), [MenuLeft](#menuleft) и [LanguagePanel](#languagepanel):

``` JSX
const Header = () => (
  <Fragment>
    <Hidden smDown>
      <MenuTop />
    </Hidden>
    <Hidden mdUp>
      <MenuLeft />
    </Hidden>
    <LanguagePanel />
  </Fragment>
)
```

Здесь:

- MenuTop – отображается на экране с шириной >= 768px
- MenuLeft – отображается на экране с шириной < 768px
- LanguagePanel – видим всегда.

Значение 768px это одна и нескольких реперных точек для media query, часть параметров нашей частной Material-UI темы, задаваемой в компоненте [Theme](#theme).

### Footer

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Footer/index.js)

Выводит на экран небольшой текст, переводимый силами React-intl.

Использует бесшовную по горизонтали, индексированную (два цвета: черный + прозрачный) картинку в формате PNG, очень легкую – всего 2.6Kb при размере 815x600 px.

### Content

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Content.js)

Выводит основное содержание.

Существенная часть исходного кода выглядит так:

``` JSX
import pages from './pages'
import NotFound from './NotFound'
import Meta from './Meta'

import { getI18nAttr } from '../lib/i18n'
import { slugToName } from '../lib/pageNaming'

// ...

const Content = props => {
  const { locale, appUrl } = props

  const pageKey = slugToName(appUrl)
  const Page = getI18nAttr(pages, locale, pageKey) || NotFound

  return (
    <Fragment>
      <Meta {...{ appUrl }} />
      <div className="Content">
        <Page {...props} />
      </div>
    </Fragment>
  )
}
```

Здесь мы выводим два компонента:

- Meta
- Page

[Компонент Meta](#meta) отвечает за установку метаданных (на данный момент это только атрибут `title`) HTML документа в зависимости от текущей страницы.

Компонент `Page` – это как раз сам контент. Однако нам надо определиться, какой именно компонент будет выступать под этим именем. Для этого мы сначала загружаем все компоненты конкретных страниц на всех языках в один объект при помощи инструкции `import pages from './pages'`, что возможно, благодаря наличию индексных файлов на двух уровнях в директории `src/components/pages`:

```
src
└─ components
   └─ pages
      ├─ index.js              <-- main index
      ├─ en
      │  ├─ index.js           <-- index inside locale
      │  │
      │  ├─ about.js
      │  ├─ contact.js
      │  ├─ experience.js
      │  ├─ open-source.js
      │  ├─ ...
      │  └─ skills.js
      └─ ru
         ├─ index.js          <-- index inside locale
         │
         ├─ about.js
         ├─ contact.js
         ├─ experience.js
         ├─ open-source.js
         ├─ ...
         └─ skills.js
```

Все эти файлы представляют из себя заранее подготовленные и готовые к использованию компоненты (см. подробнее описание подпоекта [Authoring](#2-authoring)).

В результате объект `pages` содержит в себе все контент-компоненты на всех языках:

```JavaScript
const pages = {
  en: {
    intro,
    skills,
    experience,
    open_source,
    gallery,
    education,
    about,
    contact
  },
  ru: {
    intro,
    skills,
    experience,
    open_source,
    gallery,
    education,
    about,
    contact
  }
}
```

Теперь получить компонент текущей страницы можно (в первом приближении) так:

``` JavaScript
// in real code I use:
// const Page = getI18nAttr(pages, locale, appUrl) || NotFound

const Page =
    pages[locale][appUrl]
    || pages[defaultLocale][appUrl]
    || NotFound
```

Здесь мы видим, что если страница на текущем языке отсутствует, мы используем страницу на языке по умолчанию, если же и ее нет, то выводим специальный компонент `NotFound`, играющий роль страницы с ошибкой `404 page not found`.

Здесь показан псевдокод с базовой логикой, реальный код скрыт в функции `getI18nAttr`.

Заглянем внуть индивидуального контентного компонента (он поступает сюда в готовом виде из подпроекта [Authoring](#2-authoring)):

```JSX
import React, { Fragment } from 'react'

class About extends React.Component {
  render() {
    return (
      <Fragment>
        <h1 className="Title">
          About this site
        </h1>
        <div className="PageContent">
          <p>
            Lorem and Ipsum were here...
          </p>

         ...

        </div>
      </Fragment>
    )
  }
}

export default About
```

Именно это будет выведено в качестве основного содержимого страницы.

## Компоненты разного назначения

### Meta

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Meta.js)

Использует компонент `Helmet` из пакета [react-helmet](https://www.npmjs.com/package/react-helmet) чтобы установить нужные метаданные документа HTML в зависимости от текущей страницы. На данный момент я задаю только атрибут `title`, именно он отображается как надпись на закладке в браузере вместе с favicon.

Чтобы сформировать текст для `title` на текущем языке, я задействую Reat-intl.

### NotFound

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/NotFound.js)

Компонент, выводящий на экран наш вариант страницы с ошибкой `404 page not found`.

### LanguagePanel

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Header/LanguagePanel.js)

Использует компоненты из [Material-UI](https://www.npmjs.com/package/@material-ui/core) и показывает кнопки – по одной на каждый язык (в данный момент у меня это английский и русский).

Для сайта с большим количеством языков это конечно не сработает, и надо использовать что-то другое, например, выпадающий список. Но когда языков только два или три – думаю кнопки это то что нужно.

### MenuTop

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Header/MenuTop.js)

Использует [Material-UI](https://www.npmjs.com/package/@material-ui/core). Активная кнопка изменяет цвет.

### MenuLeft

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Header/MenuLeft.js)

Аналогично с [MenuTop](#menutop).

### LastBuilt

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/LastBuilt.js)

Крохотный компонент, который затем используется внутри компонента [Footer](#footer), чтобы отобразить дату и время последней сборки сайта.

Это в основном полезно в период активной разработки, так как иногда бывает трудно понять, видишь ли ты на экране действительно самую последнюю сборку приложения или же версию из кэша браузера. Поэтому этот компонент становится видимым только когда переменная окружения `REACT_APP_DEBUG_MODE` имеет значение 'true'.

Технически, для того чтобы предоставить приложению доступ к такой отметке времени, я написал [скрипт](https://github.com/heroqu/react-i18n-site/blob/master/timestamp-the-build.js), который запускается перед каждой сборкой приложения (см. `scripts` в файле [package.json](https://github.com/heroqu/react-i18n-site/blob/master/package.json)) и который вставляет переменную `REACT_APP_BUILD_TIMESTAMP` со значением текущей отметки времени в файл `.env.local`. Позже, во время работы приложения эта переменная как и все остальные из файлов `.env` становятся доступны в приложении – см. модуль [config.js](https://github.com/heroqu/react-i18n-site/blob/master/src/config.js), который все это делает.

## React компоненты, встраиваемые в страницы

### Идея

Контент менеджер, оставаясь в рамках [подпроекта Authoring](#2-authoring), имеет возможность вставлять в разметку страниц (которые редактируются на html (pug)) любые необходимые React компоненты.

Звучит прекрасно, и на самом деле здесь нет никакого подвоха. Разве что небольшая плата, которая состоит в том, что вся эта ситуация подразумевает определенный уровень диалога, или согласования, между контент менеджером и программистом сайта: контент менеджер выстуает в роли заказчика и выражает желание по поводу определенного функционала, а программист это тот, кто может предоставить такую функциональность в форме некоторого компонента.

Хорошо, однако, то, что когда такие переговоры уже позади, и список доступных компонент известен – с этого момента контент менеджер может ипользовать эти компоненты по своему усмотрению.

### Список используемых в настоящее время

Вот список компонентов, реально используемых на сайте на текущий момент:

- [Projects](#projects)
- [Gallery](#gallery)
- [ResumeDownload](#resumedownload)
- [AppLink](#applink)
- [Link](#link)
- [A](#a)
- [MailForm](#mailform)

Опять же, с точки зрения контент менеджера, который вставляет эти компоненты в [подпроекте Authoring](#2-authoring) – все они очень напоминают черные ящики, или лучше сказать, обычные тэги html:

```
<Projects />

<Gallery name='site_for_client_n' tag='web'>Site for Company N</Gallery>

<MailForm />

<AppLink to='/about'>About page</AppLink>

Download my pdf resume <ResumeDownload>here</ResumeDownload>
```

Для того, чтобы все эти React компоненты могли работать, в процесс конвертации `pug –> react` в Gulp-е добавлена специальная трансформация, которая отыскивает все тэги начинающиеся с заглавной буквы и, считая их компонентами React, добавляет в начало файла соответствующие import-ы.

Например, если в тексте обнаружены тэги `<Fragment>`, `<Link>` и `<Gallery>`, то в начало файла будут добавлены такие строки:

```JavaScript
import React, { Fragment } from 'react'
import Link from '../../Link'
import Gallery from '../../Gallery'
```

Можно заметить, что тэг `Fragment` отработан по другому чем все остальные, и это правильно. Мы также полагаемся на то, что локально разработанные компоненты будут доступны в директории `../../`, что соответсвует `/site/src/components/`, другими словами, нужна некоторая дисциплина со стороны программиста.

### Загрузка данных и кэширование

В данный момент на сайте есть два встроенных компонента, которые подгружают данные с бэкенда,
это [Gallery](#gallery) и [Projects](#projects). Я рассматривал два основных варианта того, как организовать загрузку и хранение загруженных данных:

1. Выполнять загрузку внутри redux action и затем хранить данные в redux store
2. Выполнять загрузку в экземпляре компонента
   1. и хранить данные в состоянии компонента
   2. и хранить данные в кэше

Изначально я использовал первый вариант, при котором данные загружались в redux action и асинхронно отправлялись в redux store (с использованием redux-thunk middleware). Но в какой-то момент я понял, что хотя все прекрасно работает, тем не менее, это идет в разрез с приниципом разделения ответственностей, связанным с использованием встроенных компонент. Идея в том, что основное React приложение не должно особо ничего знать о том, что происходит с теми компонентами, которые были набросаны на контентные страницы.

С этими мыслями, я в итоге решил переключиться на второй вариант: данные загружаются в самом компоненте, код основного приложения остается незатронутым. Проблема с таким подходом заключается, однако, в том, что при смене страницы и затем возращении назад компонент на этой странице полностью разрушается и отстраивается заново, что приводит к повторной загрузке данных. Это частично смягчается кэшированием на уровне браузера, так как данные не закачиваются повтороно, если они не изменились на сервере, тем не менее, это все равно требует запроса и получение ответа в статусе 304, а это затраченное время на полный цикл запроса и ответа между клиентом и сервером.

Чтобы не делать вообще никаких лишних запросов, мы можем применить кэширование на уровне приложения. Я сделал очень простой вариант кэша в оперативной памяти, который одевается поверх функции закачки конкретного ресурса. Вот слегка сокращенный программный код этого кэша:

``` JavaScript
function FetchWithCache(fecther, ttl) {
  let value
  let timestamp

  const isExpired = () =>
    // if never fetched
    typeof timestamp !== 'number' ||
    // or, if TTL is exceeded
    Date.now() > timestamp + ttl

  return async () => {
    let isNew = false
    if (isExpired()) {
      try {
        value = await fecther()
        timestamp = Date.now()
        isNew = true
      } catch (e) {
        console.error('Error fetching data', e)
        // and now just return older data
      }
    }

    return { value, timestamp, isNew }
  }
}
```

И затем, внутри компонента __Gallery__ мы имеем:

``` JavaScript
import fetchJsonData from '../lib/fetchJsonData'
import FetchWithCache from '../../lib/FetchWithCache'

const fetcher = async () => fetchJsonData('/data/gallery.json')
const TTL = 3600000 // 1 hour Time to Live
const fetchWithCache = FetchWithCache(fetcher, TTL)

// ...

class Gallery extends Component {
  // ...

  // share images between all instances
  static images = []

  async loadData() {
    Gallery.images = (await fetchWithCache()).value

    // ...

    // go re-render
    this.setState( ... )
  }

  componentDidMount() {
    this.loadData().catch(console.error)
  }
  // ...
}
```

Здесь мы можем видеть, что загрузка как обычно стартует из `componentDidMount`, но затем используется функция закачки обернутая в кэш, так что только в самый первый раз происходит реальный запрос на сервер (а также если время жизни кэша истекло). На самом деле, если на странице более одного компонента __Gallery__ (как у меня на странице Галеря), то при первом открытии такой страницы каждый из них успеет сделать отдельный запрос к серверу, поскольку кэш еще не успел заполниться, поскольку получение данных занимает время и происходит асинхронно.

Другой интересный момент здесь в том, что мы храним полученные данные в __static images__, а не в __this.state.images__, то есть в классе, делая данные общими для всех экземпляров. А поскольку мы не храним это в `this.state`, то необходимо специально позаботиться о том, чтобы компонент обновился – либо за счет `this.setState( something )`, либо, если совсем нечего обновлять внутри `this.state`, то надо по крайней мере выполнить `this.forceUpdate()` (как это делается в компоненте `Projects`).

См. подробности реализации в исходниках:

- [FetchWithCache](https://github.com/heroqu/react-i18n-site/blob/master/src/lib/FetchWithCache.js)
- [Gallery](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Gallery.js)
- [Projects](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/index.js)

### Projects

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/index.js)

Довольно сложный встраиваемый компонент, состоящий из нескольких строительных блоков:

```
Projects
├─ ProjectFilter
│  └─ Tag                    (many)
└─ ProjectList
   └─ Accordion
      └─ AccordionSection    (many)
         ├─ ProjectTitle
         │  └─ Tag           (many)
         └─ ProjectCard
            └─ MarkDown
```

Его задача – вывести на экран список выполненных проектов и тэг-фильтр к этому списку.

Визуально пространство экрана занимаемое этим компонентом делится на две панели, на левой находится тэг-фильтр (компонент ProjectFilter), на правом – список проектов (ProjectList). На узком экране панели выстраиваются одна под другой.

__Загрузка данных__

Данные по проектам загружаются из внешнего источника данных. В данный момент это файл `/public.data/projects.json` (раздаваемый в виде статического контента основным HTTP сервером сайта), он это также легко могла бы быть и коллекция из MongoDB или что-то ещё (на самом деле я до недавнего времени как раз использовал для проектных данных MongoDB, пока не переключился на файл json).

Процесс загрузки инициируется из `ComponentDidMount`, после чего загруженные данные проходят обработку – с целью исправления нумерации, сортировки, добавления синтетических полей и извлечения тэгов. Результаты сохраняются в состоянии компонента в виде двух массивов `{ tags, projects }`, где `tags` это список всех тэгов, использованных в проектах, а `projects` – список объектов, каждый из которых содержит данные одного отдельно взятого проекта, и выглядит примерно так:

```JavaScript
const individualProject = {
  id: 1,
  badge: 2,
  badgeMinor: 0,
  badgeFull: '2',
  startDate: { $date: '2015-03-01T00:00:00.000Z' },
  endDate: { $date: '2016-05-01T00:00:00.000Z' },
  monthSpan: '2015-03 – 2016-05',
  tags: [
    'Backend development',
    'Node.js',
    'JavaScript',
    'TypeScript',
    'Express',
    'Restify',
    'Mongo',
    'Microservices',
    'RESTfull API',
    'GitFlow'
  ],
  en: {
    name: 'Node.js backend development',
    employer: 'Company name',
    description:
      "In this role I was developing microservices for a Node.js backend. ..."
  },
  ru: {
    name: 'Бэкенд разработка на Node.js',
    description:
      'В этой компании я занимался разработкой микросервисов для Node.js бэкенда. ...'
  }
}
```

### ProjectFilter

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/ProjectFilter.js)

Этот компонент заполняет свое пространство длинным списком всех доступных тэгов. Каждый из тэгов может быть выделен кликом мышки и снят с выделения повторным кликом. Список всех выбранных тэгов отображается красным шрифтом в полосе на самом верху компонента [Projects](#projects). Посетитель может воспользоваться ссылкой `Сброс`, чтобы отменить выбор тэгов и вернуть фильтр в исходное состояние.

Фильтр действует с логикой __ИЛИ__, это значит что чем больше тэгов выбрано, тем больше проектов будут показаны. Это можно сформулировать на обычном языке так: “показать все те проекты, у которых есть тэг1, ИЛИ есть тэг2, ИЛИ есть тэг3, и т.д.” Если ни одного тэга не выбрано – фильтр не действует и отображаются все проекты.

### ProjectList

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/ProjectList.js)

Этот компонент выводит список проектов, с учетом фильтра по тэгам. Каждый проект выводится внутри схлапываемой/расхлапываемой секции, компонента __AccordionSection__. Все эти секции вместе находятся внутри одного управляющего компонента __Accordion__.

### Accordion & AccordionSection

is used to introduce a collective behavior among otherwise independent expandable/collapsible sections. If the so called _Accordion mode_ is ON, then no more the one section can be expanded at a time. This is an _accordion effect_: you expand a section, the previously expanded section gets collapsed automatically. Accordion can also function in _Accordion mode_ OFF, which is equivalent to non-interference: each section can be expanded or collapsed independently.

Компонент __Accordion__ (из npm пакета [react-accordion-composable](https://www.npmjs.com/package/react-accordion-composable) с моим авторством) привносит коллективный аспект в поведение в противном случае независимых секций, каждая из которых может схлапываться или расхлапываться. Если включен так называемый _Режим Аккордеона_, то не более одной секции может одновременно быть в развернутом состоянии, другими словами, если я открываю очередную секцию, то секция которая до этого была развернута при этом свертывается. Если же _Режим Аккордеона_ отключен, то коллективное поведение отключается и все секции ведут себя независимо.

Интересная особенность моего компонента аккордион это то, что его секции применяют эффект расхлапываемости в композиционной манере. Речь о том, что обычно в аккордионах текст секции передается через props и текст тела тоже. В нашем случае заголовком секции считается первый дочерний компонент, а все следующие считаются за тело секции. Такой подход дает разделение ответственностей: аккордион занимается схлапыванием-расхлапыванием, а дочерние компоненты сами решают все остальные вопросы, что выводить на экран и как. Эти и другие особенности компонента [react-accordion-composable](https://www.npmjs.com/package/react-accordion-composable) можно посмотреть в действии на специальном [демо сайте](https://heroqu.github.io/react-accordion-composable-demo/).

В нашем случае каждая секция имеет следующие дочерние компоненты:

- __ProjectTitle__ – в качестве заголовка секции, который всегда виден
- __ProjectCard__ – в качестве тела секции, которое может быть схлопнуто или расхлопнуто

### ProjectTitle

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/ProjectTitle.js)

Выводит заголовок, его номер и список тэгов проекта.

### ProjectCard

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/ProjectCard.js)

Состоит из двух частей – верхней полосы и основной панели. В верхней полосе отображается диапазон дат проекта и название компании работодателя. В основной панели выводится описание проекта, которое на лету конвертируется из формата Markdown в React JSX при помощи отдельного компонента по имени [MarkDown](#markdown), о нем см. ниже.

### MarkDown

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Projects/MarkDown.js)

Цель этого компонента на лету преобразовать формат Markdown в React JSX.

И снова, точно так же как и в случае с фоматом `pug`, который мы используем в рамках подпроекта
[Authoring](#2-authoring), здесь мы тоже имеем возможность вставлять компоненты React непосредственно в исходный текст Markdown.

Технически, компонент представляет из себя обертку вокруг одноименного (за исключением регистра буквы `D`) компонента `Markdown` из пакета  [markdown-to-jsx](https://www.npmjs.com/package/markdown-to-jsx), дополнительно конфигурируя два правила автоматической замены тэгов:

```
<Photo> -> <Gallery className='LinkInProjectCard'>
<a> -> <ALink className='LinkInProjectCard'>
```

Если первая замена `Photo -> Gallery` заменяет лишь имя, позволяя использовать интуитивно более понятный `<Photo src=...>` для вставки картинки в тест описания, то вторая замена `<a> -> <ALink>` играет более важную роль: компонент `<ALink>` представляет из себя своего рода интеллектуальный селектор, который задействует разные компоненты в зависимости от типа адреса ссылки – внешнего, внутрисайтового или mailto (подробнее об этом см. в описании [ALink](#alink)).

### Gallery

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Gallery.js)

Компонент задействует функционал из пакета [react-image-lightbox](https://www.npmjs.com/package/react-image-lightbox) и позволяет открывать картинки в режиме lightbox, при котором текущая страница затемняется на заднем плане.

Компонент Gallery загружает свои данные сразу после монтирования и делает это почти в точности так же, как компонент [Projects](#projects).

С этого момента данные хранятся в состоянии компонента виде массива `{ images }` со списком объектов, каджый из которых несет данные отдельной картинки и выглядит примерно так:

```JavaScript
const galleryData = [
  //...,
  {
    order: 2010,
    name: 'vintergatan',
    src: '/data/gallery/sites/vintergatan.png',
    tags: 'web',
    en: {
      caption: 'Site for astrological association in Malmö, Sweden'
    },
    ru: {
      caption: 'Сайт для астрологического общества из Швеции'
    },
    year: 2002
  },
  //...
]
```

Мы видим из этого примера, что объект каждой картинки имеет атрибут `name` который можно использовать для простой адресации. Поэтому мы можем вывести на экран конкретно эту картинку при помощи следующего куска кода:

```
    <Gallery name="vintergatan" />
```

Другие режимы в которых можно открыть `Gallery`:

- для просмотра всех доступных картинок:

```
    <Gallery />
```

- для просмотра под-коллекции – только картинок с заданным тэгом (или тэгами):

```
    <Gallery tag="web">web</Gallery>
```

- для просмотра под-коллекции, начиная с заданной картинки:

```
    <Gallery name="vintergatan" tag="web">web</Gallery>
```

И я думаю это довольно гибкая система показа изображений.

Последняя ремарка по поводу `Gallery`: компонент поддерживает i18n – подписи к картинкам выводятся на текущем языке.

[Подробности реализации см. в исходниках](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Gallery.js).

### ResumeDownload

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/ResumeDownload.js)

Небольшой компонент, инкапсулирующий в себе то, что в точности должно произойти, когда пользователь нажимает на ссылку "Скачать краткое резюме".

Идея в том, что контент менеджеру не обязательно знать, где именно на сервере находится скачиваемый файл, и файл ли это, или же PDF будет генерироваться на лету, будет ли это один файл для всех языков, или же для каждого языка будет свой файл и т.д. Все эти вопросы делегируются программисту сайта и конкретное решение может быть со временем пересмотрено.

Таким образом контент менеджер может просто вставить тэг `<ResumeDownload />` в любом месте нужной страницы и забыть об этом.

### AppLink

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/AppLink.js)

Обертка вокруг компонента Link из пакета [React-router](https://www.npmjs.com/package/react-router). Если задача Link это обеспечить навигацию по сайту средствами React-router без перезагрузки приложения браузером, то эта надстройка берет на себя заботы о том, чтобы полный URL при такой навигации содержал правильный префикс текущего языка. Например, для адресации страницы _About_ на любом языке мы можем написать:

```JSX
<AppLink to='/about'>...</AppLink>
```

`AppLink` добавит недостающий префикс к атрибуту `to` во время рендеринга.

Вот исходный код этого компонента:

```JSX
import { Link } from 'react-router-dom'

const AppLink = ({ locale, to, children, className }) => (
  <Link to={`${localeURLPrefix(locale)}${to}`} className={className}>
    {children}
  </Link>
)
```

где значение префикса рассчитывается на основе текущего значения `locale`.

И это значительно упрощает использование внутренних ссылок на этапе написания контента.

Заметим, что хотя компонент [AppLink](#applink) не является абсолютно необходимым в строгом смысле слова, поскольку даже если использовать просто Link, то в итоге компонент `LocaleRouter` все равно исправит URL на правильный, тем не менее он полезен, поскольку заранее формирует правильный целевой URL, избавляя нас от ненужного redirect цикла.

### Link

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/Link.js)

Синоним (alias) для `<AppLink>`. Придуман для того, чтобы сделать написание контента в подпроекте [Authoring](#2-authoring) немного лаконичней.

### A

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/A.js)

Обертка вокруг стандартного html тэга `<a>`, с заранее установленными атрибутами:

```
  target="_blank" rel="noopener noreferrer"
```

для того, чтобы безопасно открывать вешние ссылки в новом окне браузера.

Цель этих атрибутов в том, чтобы противостоять угрозе безопасности связанной с открытием ссылки в новом окне с использованием `target="_blank"`. Суть в том, что без `rel="noopener noreferrer"` вновь открытая страница получила бы доступ объекту `window` текущей страницы посредством `window.opener` и затем могла бы злонамеренно иницировать навигацию текущей страницы на произвольный URL через `window.opener.location = newURL`, что таит в себе угрозу, в частности, фишинга. См. подробнее, например, [здесь](https://developers.google.com/web/tools/lighthouse/audits/noopener).

Теперь же, имея в распоряжении компонент `<A>`, мы можем вместо:

```html
<a href="https://github.com/heroqu/react-i18n-site"
   target="_blank"
   rel="noopener noreferrer"
>
Site repo
</a>
```

написать более лаконичный вариант:

```html
<A href="https://github.com/heroqu/react-i18n-site">
Site repo
</A>
```

### ALink

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/ALink.js)

Своего рода *умная ссылка*, компонент, который выводит на экран один из трех элементов в зависимости от типа адреса ссылки:

- если href начинается с `mailto` или не задан, то выводится обычный html тэг `<a>`.
- если href начинается с `http(s)`, выводится  [компонент A](#A), добавляющий атрибуты для безопасного открытия ссылки в новом окне.
- все остальные случаи считаем внутренними ссылками и отображаем их при помощи [компонента Link](#link), который в свою очередь основан на Link из пакета React-router.

### MailForm

:link: [source code](https://github.com/heroqu/react-i18n-site/blob/master/src/components/MailForm.js)

Компонент, задача которого вывести на экран форму обратной связи. Он задействует несколько UI компонентов из пакета [Material-UI](https://www.npmjs.com/package/@material-ui/core), некоторые напрямую (`Paper`), некоторые (`TextField` , `Button`) – опосредовано через другие компоненты. `MailForm` также использует возможности пакета [react-material-ui-form-validator](https://www.npmjs.com/package/react-material-ui-form-validator) для валидации всех полей формы, проверяя что они не пусты и что email посетителя имеет правильный формат.

После того, как пользователь нажимает на кнопку отправки, компонент формирует POST запрос к бэкенду Mailer (подробнее см. [подпроект Mailer](#4-mailer)).

Если с бэкендом нет связи, или бэкенд сломался или сам не может связаться с провайдером SMTP – на форме появляется красная надпись с сообщением о проблемах связи или сервера. Если письмо успешно отослано – отображается белая надпись сообщающая об успехе.

Подробности реализации см. в [исходном коде](https://github.com/heroqu/react-i18n-site/blob/master/src/components/MailForm.js).

# 2. Authoring

:link: [repo](https://github.com/heroqu/rs-authoring)

Этот подпроект выделен как рабочее место контент-менеджера.

Каждая страница для каждого из языков сайта готовится здесь в файла в формате `pug` (`jade`), то есть по сути в html.

В техническом плане процесс подготовки контента состоит из следующих шагов:

1.  Заполнить файлы контентом формате `pug` (это единственный не автоматизированный этап)

2.  __gulp pug2React__ – запустить задачу Gulp для конвертации всех файлов `pug` в формат `React JSX`

3.  __gulp indexBuildDir__ – вставить файлы `index.js` в директорию каждого языка и саму корневую директорию `build`:

```
authoring
└── build
    ├── en
    │   ├── index.js      <-- this one
    │   ├── About.js
    │   ├── Contact.js
    │   ├── ...
    │   └── Skills.js
    ├── ru
    │   ├── index.js      <-- this one
    │   ├── About.js
    │   ├── Contact.js
    │   ├── ...
    │   └── Skills.js
    └── index.js          <-- and this one in the root
```

Я написал специальный скрипт [authoring/lib/indexBuildDir.js](https://github.com/heroqu/rs-authoring/blob/master/lib/indexBuildDir.js), которые делает всю тяжелую работу для выполнения этой задачи.

Цель всех этих файлов `index.js` – дать возможность импортировать все страницы одной командой import:

```JavaScript
import pages from 'path_to_build_dir'
```

Эта операция импорт происходит внутри приложения React, которое является потребителем всех контент-страниц. Поэтому то, что мы генерируем все эти индексные файлы здесь, в подпроекте Authoring, __увеличивает уровень развязки__ между двуми подпроектами.

В самом деле, все компоненты страниц импортируются скопом (это происходит в компоненте [Content ](#content)) без различения имен. И только в самый последний момент во время рендеринга, когда URL требует вывести на экран страницу с конкретным именем – только тогда становится ясно, имеется ли у нас в наличии страница с таким именем или нет. Это происходит в run time. А в compile time React приложение не особо чувствительно к тому, что конкретно у него припасено в плане страниц в папке `src/components/pages`.

4.  __gulp export__ – экспортировать (просто скопировать) все полученные файлы `React JSX` в директорию подпроекта Site (основное React приложение).

# 3. Translating

:link: [repo](https://github.com/heroqu/rs-translating)

Этот подпроект используется для облегчения подготовки переводов ключевых фраз для пакета [React-intl](https://www.npmjs.com/package/react-intl). Все рутинные операции автоматизироваены и выполняются как задачи Gulp.

Основные файлы проекта расположены так:

```
translating
├── build
│   └── messages.json
├── edited
│   ├── en.json
│   ├── ru.json
│   └── ...
├── extracted
│   ├── Component1.json
│   ├── Component2.json
│   └── ...
├── sample
│   └── sample.json
│
├── gulpfile.js
└── package.json
```

Подготовка переводов выполняется в несколько этапов:

- `gulp extract`

  - Извлекает ключевые, требующие перевода, строки из всех React компонентов присутствующих в директории основного сайта и помещает их в директорию `/extracted`. Для этого ищутся все вхождения компонент `<FormattedMessage>` в тексты JSX файлов.

- `gulp sample`

  - Соединяет все полученные ключи в один общий файл `/sample/sample.json`. Этот файл содержит все ключевые строки одного отдельно взятого языка и может рассматриваться как стартовый образец для всех языков.

- Далее требуется вмешательство человека. Нужно сделать столько копий этого файла, сколько есть языков на сайте, назвать их по имени языка (например, en.json, ru.json и т.д.), разместить их в директории /edited и отредактировать, добавив переводы.

- `gulp build`

  - Эта задача соединяет все эти готовые файлы переводов в один `/build/messages.json`

- `gulp deploy`
  - копирует файл `/build/messages.json` непосредственно в директорию основного React сайта.

# 4. Mailer

:link: [repo](https://github.com/heroqu/mailer)

Небольшой сервер, предоставляющий HTTP API для отправки почтовых сообщений.

Может использоваться как бэкенд для форм обратной связи. Он берет на себя заботы по отправке сообщений и эффективно скрывает от клиента пароли и ключи аутентификации (которые были бы доступны клиету, если бы мы выполняли отправку непосредственно из приложения React, чей код всегда доступен для просмотра).

Основан на Express и [Nodemailer](https://www.npmjs.com/package/nodemailer) и имеет простой API: он слушает входящие POST запросы на адресе `/send`.

Доступны два вида доставки:
- Gmail
  - отправляет SMTP запросы на указанный Gmail эккаунт.
- [Mailgun](https://www.mailgun.com/)
  - отправляет HTTP запросы на MAIL API этого провайдера.

Для отправки сообщения клиент должен сформировать POST запрос с параметрами `{ name, email, subject, message }` в своем теле. После получения нового запроса, сервер делает следующее:

- Извлекает из тела запроса параметры name, email, subject, message
- Проверяет эти параметры:
  - Проверяет, что ни одно из этих полей не пусто
  - Проверяет, что email выглядит как настоящий email
  - Если хотя бы одна из проверок не проходит – возвращает ответ с HTTP статусом 400 и соответствующим сообщением.
- Производит очистку всех этих полей от html тэгов.
- Формирует почтовое сообщение
- Пытается отправить это сообщение одним из видов доставки (Mailgun или Gmail) при помощи [Nodemailer](https://www.npmjs.com/package/nodemailer)
- Если доставка не удалась – передает на клиент ответ с ошибкой полученной от Nodemailer.

Поскольку этот http сервер работает на отдельном URL, который отличается от URL основного сайта, то для успешного приема сообщений с сайта используется Express CORS middleware (пакет [cors](https://www.npmjs.com/package/cors)). В настройках CORS используется белый список адресов с которых допускается прием сообщений.

Все настройки сервера, включая белый список адресов для CORS, ключи и пароли почты, вариант доставки и порт сервера, устанавливаются через переменные окружения, либо непосредственно, либо через один из файлов `.env` (который затем читается и применяется пакетом  [dotenv](https://www.npmjs.com/package/dotenv)).

В production запускается как отдельный Docker микросервис (подробнее об этом см. [описание подпроекта Deploy](#5-deploy)).

# 5. Deploy

:link: [repo](https://github.com/heroqu/rs-deploy)

Подпроект, содержащий конфигурационный файл [docker-compose](https://docs.docker.com/compose/) для запуска серверов [Site](#1-site-the-react-application) и [Mailer](#mailer) в виде двух Docker микросервисов. Директории `/site` и `/mailer` являются соседними по отношению к `/deploy`, и потому для упрощения обращения к ним из данного подпроекта они отражаются здесь через symlink-и:

```
deploy
├── docker-compose.yml
├── mailer -> ../mailer
└── site -> ../site
```

В то же время подпроекты Site и Mailer имеет свои собственные Dockerfile-ы и в итоге docker-compose должен работать со следующей конфигурацией файлов:

```
deploy
├── docker-compose.yml
├── mailer -> ../mailer
│   ├── Dockerfile
│   └── ...
└── site -> ../site
    ├── Dockerfile
    └── ...
```

Таким образом, все нужные файлы оказываются в пределах подпроекта (если симлинки не сломаны).

## Some specificities in Dockerfiles

Рассмотрим файл Dockerfile из подпроекта [Site](#1-site-the-react-application) (исходный код [здесь](https://github.com/heroqu/react-i18n-site/blob/master/Dockerfile)):

```Dockerfile
# /site/Dockerfile

ARG DISTRO=node:10.6.0-alpine

ARG SERVE_VERSION=9.2.0

FROM $DISTRO as builder

WORKDIR /usr/src/app

COPY package*.json ./

RUN npm install

COPY . .

RUN npm run build

FROM $DISTRO as deploy

RUN npm i -g serve@$SERVE_VERSION

WORKDIR /usr/src/app

COPY --from=builder /usr/src/app/build/ .

ENV PORT=3010

EXPOSE $PORT

CMD ["serve"]
```

Здесь можно заметить, что:

- Мы используем инструкции `ARG` для параметризации базового linux образа и версии пакета [serve](https://www.npmjs.com/package/serve). Оба этих параметра могут далее быть переопределены в файле `docker-compose.yml`.

- Переменная окружения `PORT` также параметризована и может быть переопределена в `docker-compose.yml`. В этом случае мы вместо `ARG` используем `ENV`, так как эта переменная понадобится в run-time – во время запуска контейнера для работы сервера [serve](https://www.npmjs.com/package/serve).

- `EXPOSE $PORT` преследует двоякую цель:

  - Открывает указанный порт у всего контейнера
  - Устанавливает рабочий порт для сервера [serve](https://www.npmjs.com/package/serve), который (начиная с версии 9.1) умеет брать порт из переменной окружения `PORT`.
    - И здесь нам повезло, поскольку если бы не это, было бы сложнее задать порт для serve, поскольку Docker инструкция `CMD` на данный момент не поддерживает экспансию переменных в своей exec версии. Другими словами мы не можем просто написать: `CMD ["serve", "-p", "$PORT"]` – это не сработает. И мы также не готовы так просто расстаться с exec формой для `CMD`, поэтому какие-то обходные пути были бы неизбежны.

- и, наконец, мы пользуемся многоступенчатым построением образа ([Docker multistage builds](https://docs.docker.com/develop/develop-images/multistage-build/)) чтобы сделать конечный продуктовый образ немного легче и чище.
  - для этого мы сначала устанавливаем приложение и все его зависимости, затем строим сборку (с `npm run build`). В этот момент мы начинаем новый образ (той же самой версии) и копируем туда директорию со сборкой из предыдущего этапа. Мы также глобально устанавливаем пакет [serve](https://www.npmjs.com/package/serve) чтобы запускать его как http сервер для нашего статического сайта.

Dockerfile для [Mailer](#4-mailer) очень похож (см. [исходный код](https://github.com/heroqu/mailer/blob/master/Dockerfile)), за исключением того, что от не устанавливает [serve](https://www.npmjs.com/package/serve), но зато устанавливает `node-gyp`, без которого мы получили бы ошибку на стадии npm install основного сервера:

```Dockerfile
# for some npm packages to be able to build natively
# we need node-gyp
# see https://github.com/nodejs/docker-node/issues/282
RUN apk add --no-cache --virtual .gyp python make
```

## docker-compose.yml

Ничего экзотичного, вот [исходный код](https://github.com/heroqu/rs-deploy/blob/master/docker-compose.yml).

